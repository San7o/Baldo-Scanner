#include "daemon/malware_db.hpp"
#include "daemon/yara.hpp"
#include "common/logger.hpp"
#include "common/utils.hpp"

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <filesystem>

#include <curlpp/cURLpp.hpp>
#include <curlpp/Options.hpp>

using namespace AV;

MalwareDB::MalwareDB(std::string filename)
{
    if(!std::filesystem::exists(filename))
    {
        std::ofstream file(filename);
        file.close();
    }
    int rc = sqlite3_open(filename.c_str(), &this->connection);
    if (rc != SQLITE_OK)
    {
        Logger::Log(Enums::LogLevel::ERROR, "Can't open database: " + std::string(sqlite3_errmsg(connection)));
        sqlite3_close(connection);
    }
}

MalwareDB::~MalwareDB()
{
    sqlite3_close(this->connection);
}

int MalwareDB::fetch()
{
    // Malware signatures database
    Logger::Log(Enums::LogLevel::INFO, "Fetching malware signatures database");
    std::cout << std::flush;
    
    std::ofstream out("/tmp/signatures-latest.csv", std::ios::trunc);
    out << curlpp::options::Url("https://bazaar.abuse.ch/export/csv/recent");

    Logger::Log(Enums::LogLevel::INFO, "Fetched database to /tmp/signatures-latest.csv");
    out.close();

    // Yara rules
    Logger::Log(Enums::LogLevel::INFO, "Fetching yara-rules");
    std::ofstream out2("/tmp/yara-rules.zip", std::ios::trunc);
    out2 << curlpp::options::Url("https://yaraify.abuse.ch/yarahub/yaraify-rules.zip");
    out2.close();

    if (std::filesystem::exists("/etc/antivirus/yara-rules"))
    {
        std::filesystem::remove_all("/etc/antivirus/yara-rules");
    }
    if (std::system("unzip /tmp/yara-rules -d /etc/antivirus/yara-rules/") == -1)
    {
        Logger::Log(Enums::LogLevel::ERROR, "Failed to fetch yara-rules");
        return -1;
    }
    Logger::Log(Enums::LogLevel::INFO, "Fetched yara-rules to /etc/antivirus/yara-rules");

    Logger::Log(Enums::LogLevel::INFO, "Compiling YARA rules");
    Yara::CompileRules("/etc/antivirus/yara-rules");
    Logger::Log(Enums::LogLevel::OUT, "Compiled YARA rules to /etc/antivirus/compiled_rules.yar");
    return 0;
}

/**
 * CSV file structure:
 * "first_seen_utc","sha256_hash","md5_hash","sha1_hash","reporter",
 * "file_name","file_type_guess","mime_type","signature","clamav",
 * "vtpercent","imphash","ssdeep","tlsh"
 */
int MalwareDB::load(std::string path)
{
    Logger::Log(Enums::LogLevel::INFO, "Loading malware signatures database");
    char* errMsg = nullptr;

    if (this->connection == nullptr)
    {
        Logger::Log(Enums::LogLevel::ERROR, "Database not connected yet");
        return -1;
    }

    std::string createTableSQL = "CREATE TABLE IF NOT EXISTS signatures("
        "first_seen_utc TEXT, sha256_hash TEXT PRIMARY KEY, "
        "md5_hash TEXT, sha1_hash TEXT, reporter TEXT, file_name TEXT, "
        "file_type_guess TEXT, mime_type TEXT, signature TEXT, clamav TEXT, "
        "vtpercent TEXT, imphash TEXT, ssdeep TEXT, tlsh TEXT);";

    int rc = sqlite3_exec(connection, createTableSQL.c_str(), nullptr, nullptr, &errMsg);
    check_sqlite_error(rc, connection);

    std::ifstream csvFile(path);
    std::string line;
    std::string insertSQL = "INSERT INTO signatures (first_seen_utc, sha256_hash, md5_hash,"
            " sha1_hash, reporter, file_name, file_type_guess, mime_type, signature, clamav,"
            " vtpercent, imphash, ssdeep, tlsh ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    sqlite3_stmt* stmt;

    rc = sqlite3_prepare_v2(connection, insertSQL.c_str(), -1, &stmt, nullptr);
    check_sqlite_error(rc, connection);

    rc = sqlite3_exec(connection, "BEGIN TRANSACTION;", nullptr, nullptr, nullptr);
    check_sqlite_error(rc, connection);
    
    while (std::getline(csvFile, line))
    {
        std::istringstream ss(line);
        
        for (int i = 0; i < 14; i++)
        {
            std::string col;
            std::getline(ss, col, ',');
            rc = sqlite3_bind_text(stmt, i + 1, col.c_str(), -1, SQLITE_TRANSIENT);
            check_sqlite_error(rc, connection);
        } 

        sqlite3_step(stmt);
        sqlite3_reset(stmt);
    }

    rc = sqlite3_exec(connection, "END TRANSACTION;", nullptr, nullptr, nullptr);
    check_sqlite_error(rc, connection);
    
    Logger::Log(Enums::LogLevel::OUT, "Loaded malware signatures database");
    sqlite3_finalize(stmt);
    return 0;
}

int MalwareDB::update() 
{
   if (fetch() < 0)
   {
       return -1;
   }
   if (load("/tmp/signatures-latest.csv") < 0)
   {
       return -1;
   }
   return 0;
}
